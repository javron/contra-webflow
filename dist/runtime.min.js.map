{"version":3,"sources":["../src/runtime.ts","../../contra-client/src/client.ts"],"sourcesContent":["import { ContraClient, utils } from '@contra/client';\nimport type {\n  ExpertProfile,\n  ExpertFilters,\n  FilterChangeEvent,\n  ExpertLoadEvent,\n  ErrorEvent,\n  ExpertField\n} from '@contra/types';\n\n/**\n * Webflow Runtime for Contra Experts\n * Simplified for flexibility and predictability.\n */\n\n// Simplified configuration\ninterface RuntimeConfig {\n  apiKey: string;\n  debug?: boolean;\n  loadingClass?: string;\n  errorClass?: string;\n  emptyClass?: string;\n  // Video configuration\n  videoAutoplay?: boolean;\n  videoHoverPlay?: boolean;\n  videoMuted?: boolean;\n  videoLoop?: boolean;\n  videoControls?: boolean;\n  // Cloudinary transformations\n  imageTransformations?: string;\n  videoTransformations?: string;\n  optimizeGifsAsVideo?: boolean;\n  contraAnalytics?: boolean;\n}\n\nconst CLOUDINARY_TRANSFORM_PREFIXES = [\n  'w_', 'h_', 'c_', 'f_', 'q_', 'fl_', 'vc_', 'b_', 'e_', 'o_', 'a_', 'dpr_', 'ar_'\n];\n\n// Attribute constants\nconst ATTR_PREFIX = 'data-contra-';\nconst ATTRS = {\n  // Core list attributes\n  listId: 'list-id',\n  program: 'program',\n  template: 'template',\n  \n  // States\n  loading: 'loading',\n  error: 'error',\n  empty: 'empty',\n  \n  // Field binding\n  field: 'field',\n  format: 'format',\n  \n  // Repeating elements\n  repeat: 'repeat',\n  max: 'max',\n  \n  // Sorting and pagination\n  limit: 'limit',\n  \n  // Actions\n  action: 'action',\n  listTarget: 'list-target',\n\n  // Conditional display\n  showWhen: 'show-when',\n  hideWhen: 'hide-when',\n  prerenderPlaceholders: 'prerender-placeholders'\n} as const;\n\n// State management is now keyed by the list's unique ID\nclass RuntimeState {\n  private states = new Map<string, {\n    filters: ExpertFilters;\n    experts: ExpertProfile[];\n    loading: boolean;\n    error: Error | null;\n    offset: number;\n    limit: number;\n    totalCount: number;\n    hasNextPage: boolean;\n  }>();\n\n  getState(listId: string) {\n    if (!this.states.has(listId)) {\n      this.states.set(listId, {\n        filters: {},\n        experts: [],\n        loading: false,\n        error: null,\n        offset: 0,\n        limit: 20, // Default limit\n        totalCount: 0,\n        hasNextPage: false\n      });\n    }\n    return this.states.get(listId)!;\n  }\n\n  updateState(listId: string, updates: Partial<ReturnType<RuntimeState['getState']>>) {\n    const state = this.getState(listId);\n    Object.assign(state, updates);\n    this.states.set(listId, state);\n  }\n}\n\n/**\n * Main Runtime Class\n */\nexport class ContraWebflowRuntime {\n  private client: ContraClient;\n  private config: Required<RuntimeConfig>;\n  private state = new RuntimeState();\n  private debouncedReload: Map<string, () => void> = new Map();\n  private filterNameMap: Record<string, string> = {\n    locations: 'location',\n  };\n  private filterOptionLabels: Record<string, Record<string, string>> = {\n    sortBy: {\n      relevance: 'Relevance',\n      oldest: 'Oldest',\n      newest: 'Newest',\n      rate_asc: 'Rate (Low to High)',\n      rate_desc: 'Rate (High to Low)'\n    }\n  };\n\n  constructor(config: RuntimeConfig) {\n    this.config = {\n      debug: false,\n      loadingClass: 'loading',\n      errorClass: 'error',\n      emptyClass: 'empty',\n      // Video configuration defaults\n      videoAutoplay: false,\n      videoHoverPlay: true,\n      videoMuted: true,\n      videoLoop: true,\n      videoControls: false,\n      // Cloudinary transformation defaults\n      imageTransformations: 'f_auto,q_auto:eco,c_limit,w_800',\n      videoTransformations: 'fl_progressive,f_auto,q_auto:eco,vc_auto,c_limit,h_720',\n      optimizeGifsAsVideo: true,\n      contraAnalytics: true,\n      ...config\n    };\n\n    this.client = new ContraClient({\n      apiKey: this.config.apiKey,\n      debug: this.config.debug\n    });\n\n    this.log('Runtime initialized', this.config);\n  }\n\n  /**\n   * Initialize the runtime by finding and setting up all lists.\n   */\n  async init(): Promise<void> {\n    this.log('Initializing runtime...');\n\n    try {\n      // 1. Discover all lists and unique programs to fetch filters for\n      const listElements = this.querySelectorAll(document.body, `[${ATTR_PREFIX}${ATTRS.listId}]`);\n      this.log(`Found ${listElements.length} lists to initialize.`);\n      \n      const programFilters = new Map<string, any[]>();\n      for (const listElement of listElements) {\n        const programId = this.getAttr(listElement, ATTRS.program);\n        if (programId && !programFilters.has(programId)) {\n          this.log(`Fetching filters for program: ${programId}`);\n          programFilters.set(programId, await this.getAvailableFilters(programId));\n        }\n      }\n\n      // 2. Populate all filter controls on the page once\n      this.populateAllFilterControls(programFilters);\n\n      // 3. Initialize each list\n      for (const listElement of listElements) {\n        await this.initList(listElement);\n      }\n\n      // 4. Wire up all action buttons and filter controls\n      this.wireActionButtons();\n      this.wireFilterControls();\n\n      this.log('Runtime initialization complete');\n    } catch (error) {\n      this.log('Runtime initialization failed', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Initialize a single expert list.\n   */\n  private async initList(listElement: Element): Promise<void> {\n    const listId = this.getAttr(listElement, ATTRS.listId);\n    const programId = this.getAttr(listElement, ATTRS.program);\n\n    if (!listId || !programId) {\n      this.log('List element is missing required attributes `data-contra-list-id` or `data-contra-program`.', listElement);\n      return;\n    }\n\n    this.log(`Initializing list: ${listId} for program: ${programId}`);\n\n    try {\n      (listElement as HTMLElement).setAttribute('data-contra-initialized', 'true');\n      (listElement as HTMLElement).classList.add('contra-list');\n      \n      const limit = parseInt(this.getAttr(listElement, ATTRS.limit) || '20', 10);\n      const template = this.querySelector(listElement, `[${ATTR_PREFIX}${ATTRS.template}]`);\n\n      // Prerender placeholders if requested, before the original template is hidden\n      if (template && listElement.hasAttribute(`${ATTR_PREFIX}${ATTRS.prerenderPlaceholders}`)) {\n        this.log(`Prerendering ${limit} placeholders for list: ${listId}`);\n        for (let i = 0; i < limit; i++) {\n          const placeholder = template.cloneNode(true) as Element;\n          placeholder.removeAttribute(`${ATTR_PREFIX}${ATTRS.template}`);\n          placeholder.classList.add('contra-placeholder-item');\n          (placeholder as HTMLElement).style.display = ''; // Ensure placeholder is visible\n          listElement.appendChild(placeholder);\n        }\n      }\n      \n      if (template) {\n          (template as HTMLElement).style.display = 'none';\n          this.log(`Template found and hidden for list: ${listId}`);\n      }\n      \n      // Defensively remove inline display styles from state elements to prevent conflicts.\n      const loadingEl = this.querySelector(listElement, `[${ATTR_PREFIX}${ATTRS.loading}]`);\n      if (loadingEl) (loadingEl as HTMLElement).style.removeProperty('display');\n      const emptyEl = this.querySelector(listElement, `[${ATTR_PREFIX}${ATTRS.empty}]`);\n      if (emptyEl) (emptyEl as HTMLElement).style.removeProperty('display');\n\n      const initialFilters = this.parseFiltersFromElement(listElement);\n      \n      this.state.updateState(listId, { \n      filters: initialFilters,\n        limit: limit,\n        offset: initialFilters.offset || 0,\n      });\n      \n      this.state.updateState(listId, { loading: true, error: null });\n      this.showLoading(listElement, true);\n\n      const response = await this.client.listExperts(programId, initialFilters);\n      \n      this.log(`Loaded ${response.data.length} experts for list ${listId}`, response);\n\n      const newExperts = response.data;\n      const allExperts = newExperts;\n\n      // Update state before touching the DOM\n      this.state.updateState(listId, {\n        experts: allExperts,\n        totalCount: response.totalCount,\n        offset: initialFilters.offset || 0 + newExperts.length,\n        hasNextPage: newExperts.length === limit,\n        loading: false\n      });\n\n      // Render experts and then immediately update all UI states\n      this.renderExperts(listElement, newExperts, false);\n      this.updateUIStates(listElement, listId);\n\n    } catch (error) {\n      this.log(`Failed to initialize list ${listId}`, error);\n      this.state.updateState(listId, { loading: false, error: error as Error });\n      this.showError(listElement, error as Error);\n    } finally {\n      this.showLoading(listElement, false);\n    }\n  }\n\n  /**\n   * Wire up all action buttons on the page.\n   */\n  private wireActionButtons(): void {\n    const actionButtons = this.querySelectorAll(document.body, `[${ATTR_PREFIX}${ATTRS.action}]`);\n    \n    actionButtons.forEach(button => {\n      const action = this.getAttr(button, ATTRS.action);\n      const targetListId = this.getAttr(button, ATTRS.listTarget);\n      \n      if (!action || !targetListId) {\n        this.log('Action button is missing required `data-contra-action` or `data-contra-list-target` attributes.', button);\n        return;\n      }\n\n      button.addEventListener('click', (e) => {\n        e.preventDefault();\n        this.handleAction(action, targetListId, button);\n      });\n    });\n  }\n\n  /**\n   * Load experts for a given list.\n   */\n  private async loadExperts(listId: string, programId: string, append = false): Promise<void> {\n    const listElement = this.querySelector(document.body, `[${ATTR_PREFIX}${ATTRS.listId}=\"${listId}\"]`);\n    if (!listElement) {\n      this.log(`Cannot find list element with ID: ${listId}`);\n          return;\n        }\n\n    // When reloading the list (not appending), we must hide the empty state message first.\n    const emptyElement = this.querySelector(listElement, `[${ATTR_PREFIX}${ATTRS.empty}]`);\n    if (!append && emptyElement) {\n        (emptyElement as HTMLElement).style.display = 'none';\n    }\n\n    const state = this.state.getState(listId);\n    const filters = {\n      ...state.filters,\n      limit: state.limit,\n      offset: state.offset,\n    };\n    \n    this.log(`Loading experts for list: ${listId}`, filters);\n\n    try {\n      this.showLoading(listElement, true);\n      this.state.updateState(listId, { loading: true, error: null });\n\n      const response = await this.client.listExperts(programId, filters);\n      \n      this.log(`Loaded ${response.data.length} experts for list ${listId}`, response);\n\n      const newExperts = response.data;\n      const allExperts = append ? [...state.experts, ...newExperts] : newExperts;\n\n      // Update state before touching the DOM\n      this.state.updateState(listId, {\n        experts: allExperts,\n        totalCount: response.totalCount,\n        offset: state.offset + newExperts.length,\n        hasNextPage: newExperts.length === state.limit,\n        loading: false\n      });\n\n      // Render experts and then immediately update all UI states\n      this.renderExperts(listElement, newExperts, append);\n      this.updateUIStates(listElement, listId);\n\n    } catch (error) {\n      this.log(`Failed to load experts for list: ${listId}`, error);\n      this.state.updateState(listId, { loading: false, error: error as Error });\n      this.showError(listElement, error as Error);\n    } finally {\n      // Always ensure loading state is removed\n      this.showLoading(listElement, false);\n    }\n  }\n\n  /**\n   * Render experts into the container. Can clear or append.\n   */\n  private renderExperts(listElement: Element, experts: ExpertProfile[], append: boolean): void {\n    const template = this.querySelector(listElement, `[${ATTR_PREFIX}${ATTRS.template}]`);\n    if (!template) {\n      this.log('No template found in list', listElement);\n      return;\n    }\n    const listId = this.getAttr(listElement, ATTRS.listId)!;\n\n    // Handle prerendered placeholders on initial load\n    const placeholders = this.querySelectorAll(listElement, '.contra-placeholder-item');\n    if (!append && placeholders.length > 0) {\n      this.log(`Populating ${experts.length} of ${placeholders.length} placeholders for list.`);\n      \n      experts.forEach((expert, i) => {\n        const placeholder = placeholders[i];\n        if (placeholder) {\n          this._configureCard(placeholder, expert, listId);\n          placeholder.classList.remove('contra-placeholder-item');\n        }\n      });\n\n      // Remove any unused placeholders\n      if (experts.length < placeholders.length) {\n        this.log(`Removing ${placeholders.length - experts.length} unused placeholders.`);\n        for (let i = experts.length; i < placeholders.length; i++) {\n          placeholders[i].remove();\n        }\n      }\n      this.log(`Finished rendering placeholders for list`, listElement);\n      return; // Skip the standard rendering path\n    }\n\n    if (!append) {\n      // Clear only previously rendered expert cards\n      const existingCards = this.querySelectorAll(listElement, '.contra-rendered-item');\n    existingCards.forEach(card => card.remove());\n    }\n\n    const fragment = document.createDocumentFragment();\n    experts.forEach(expert => {\n      const expertCard = this.populateExpertCard(template, expert, listId);\n      fragment.appendChild(expertCard);\n    });\n    listElement.appendChild(fragment);\n\n    this.log(`Rendered ${experts.length} expert cards into list`, listElement);\n  }\n\n  /**\n   * Populate expert card from template\n   */\n  private populateExpertCard(template: Element, expert: ExpertProfile, listId: string): Element {\n    const card = template.cloneNode(true) as Element;\n    this._configureCard(card, expert, listId);\n    return card;\n  }\n\n  /**\n   * Configures an existing card element with expert data, including all sub-fields and repeaters.\n   * This is the core rendering logic for a single item.\n   */\n  private _configureCard(card: Element, expert: ExpertProfile, listId: string): void {\n    // Add a marker class to identify this as a rendered card\n    card.classList.add('contra-rendered-item');\n    \n    // Remove template attribute and show the card\n    card.removeAttribute(`${ATTR_PREFIX}${ATTRS.template}`);\n    (card as HTMLElement).style.display = '';\n\n    // --- Fix for repeater template pollution ---\n    // 1. Temporarily detach repeater templates\n    const repeatContainers = this.querySelectorAll(card, `[${ATTR_PREFIX}${ATTRS.repeat}]`);\n    const detachedTemplates = new Map<Element, DocumentFragment>();\n    repeatContainers.forEach(container => {\n        const fragment = document.createDocumentFragment();\n        while (container.firstChild) {\n            fragment.appendChild(container.firstChild);\n        }\n        detachedTemplates.set(container, fragment);\n    });\n\n    // 2. Populate fields on the main card (now safely without repeater templates)\n    this.populateFields(card, expert, listId);\n    \n    // 3. Re-attach the pristine templates\n    detachedTemplates.forEach((fragment, container) => {\n        container.appendChild(fragment);\n    });\n\n    // 4. Handle repeating elements, which will now use the clean templates\n    this.populateRepeatingElements(card, expert, listId);\n    \n    // Handle conditional display\n    this.handleConditionalDisplay(card, expert);\n  }\n\n  /**\n   * Populate data fields in the card\n   */\n  private populateFields(card: Element, expert: ExpertProfile, listId: string): void {\n    const fieldElements = this.querySelectorAll(card, `[${ATTR_PREFIX}${ATTRS.field}]`);\n    \n    fieldElements.forEach(element => {\n      const fieldName = this.getAttr(element, ATTRS.field) as ExpertField;\n      const format = this.getAttr(element, ATTRS.format);\n      \n      if (!fieldName || !(fieldName in expert)) return;\n\n      const value = expert[fieldName];\n      this.setElementValue(element, value, format, listId);\n    });\n\n    // Handle star ratings\n    const starsElements = this.querySelectorAll(card, '[data-contra-stars]');\n    starsElements.forEach(element => {\n      if (expert.averageReviewScore) {\n        this.renderStarRating(element, expert.averageReviewScore);\n      }\n    });\n  }\n\n  /**\n   * Set element value with proper formatting\n   */\n  private setElementValue(element: Element, value: any, format?: string | null, listId?: string): void {\n    if (value == null || value === '') return;\n\n    // Media type detection and handling\n    if (this.isMediaField(element) && typeof value === 'string' && value.trim()) {\n      this.setMediaValue(element, value);\n      return;\n    }\n\n    if (element instanceof HTMLAnchorElement) {\n      let href = String(value);\n      if (listId) {\n          href = this._appendContraAnalytics(href, listId);\n      }\n      element.href = href;\n      if (element.children.length === 0 && !element.textContent?.trim()) {\n        element.textContent = String(value);\n      }\n    } else if (element instanceof HTMLInputElement) {\n      element.value = String(value);\n    } else if (element instanceof HTMLImageElement) {\n      // Regular image handling for avatars and other images\n      const mediaType = this.detectMediaType(String(value));\n      const transformedUrl = this.transformMediaUrl(String(value), mediaType);\n      element.src = transformedUrl;\n      element.alt = element.alt || 'Image';\n    } else {\n      // Text content with formatting\n      let displayValue = String(value);\n      \n      if (format) {\n        switch (format) {\n          case 'currency':\n            displayValue = typeof value === 'number' ? `$${value}` : displayValue;\n            break;\n          case 'rate':\n            displayValue = utils.formatRate(typeof value === 'number' ? value : null);\n            break;\n          case 'rating':\n            // Format rating to one decimal place (5.0, 4.9, etc.)\n            displayValue = typeof value === 'number' ? value.toFixed(1) : displayValue;\n            break;\n          case 'earnings':\n            // Format earnings like $25k+\n            if (typeof value === 'number') {\n              if (value >= 1000000) {\n                displayValue = `$${Math.floor(value / 1000000)}M+`;\n              } else if (value >= 1000) {\n                displayValue = `$${Math.floor(value / 1000)}k+`;\n              } else {\n                displayValue = `$${value}`;\n              }\n            }\n            break;\n          case 'number':\n            displayValue = typeof value === 'number' ? value.toLocaleString() : displayValue;\n            break;\n          case 'truncate':\n            displayValue = displayValue.length > 100 ? displayValue.substring(0, 97) + '...' : displayValue;\n            break;\n          case 'boolean':\n            displayValue = value ? 'Yes' : 'No';\n            break;\n          case 'availability':\n            displayValue = value ? 'Available' : 'Not Available';\n            break;\n        }\n      }\n      \n      element.textContent = displayValue;\n    }\n  }\n\n  /**\n   * Star rating rendering with optional text display\n   */\n  private renderStarRating(element: Element, rating: number): void {\n    const fullStars = Math.floor(rating);\n    const hasHalfStar = rating % 1 >= 0.5;\n    const emptyStars = 5 - fullStars - (hasHalfStar ? 1 : 0);\n    \n    let starsHtml = '';\n    \n    // Full stars\n    for (let i = 0; i < fullStars; i++) {\n      starsHtml += '<span class=\"contra-star contra-star-full\">â˜…</span>';\n    }\n    \n    // Half star\n    if (hasHalfStar) {\n      starsHtml += '<span class=\"contra-star contra-star-half\">â˜…</span>';\n    }\n    \n    // Empty stars\n    for (let i = 0; i < emptyStars; i++) {\n      starsHtml += '<span class=\"contra-star contra-star-empty\">â˜†</span>';\n    }\n    \n    element.innerHTML = starsHtml;\n    \n    // Also update any rating text elements in the same card\n    const card = element.closest('[data-contra-template]') || element.closest('.expert-card');\n    if (card) {\n      const ratingTextElements = this.querySelectorAll(card, '[data-contra-rating-text]');\n      ratingTextElements.forEach(textElement => {\n        textElement.textContent = rating.toFixed(1);\n      });\n    }\n  }\n\n  /**\n   * Media type detection and element handling\n   */\n  private isMediaField(element: Element): boolean {\n    const field = this.getAttr(element, ATTRS.field);\n    // Only apply advanced media handling to project cover URLs, not avatars\n    return field === 'coverUrl';\n  }\n\n  /**\n   * Media value setting with automatic type detection\n   */\n  private setMediaValue(element: Element, url: string): void {\n    const mediaType = this.detectMediaType(url);\n    const parent = element.parentElement;\n    \n    if (!parent) {\n      this.log('Media element has no parent for replacement', element);\n      return;\n    }\n\n    // Remove existing media element\n    element.remove();\n\n    // Create appropriate media element\n    let mediaElement: HTMLElement;\n    \n    switch (mediaType) {\n      case 'video':\n        const transformedVideoUrl = this.transformMediaUrl(url, 'video');\n        mediaElement = this.createVideoElement(transformedVideoUrl, element);\n        break;\n      case 'image':\n      default:\n        const transformedImageUrl = this.transformMediaUrl(url, 'image');\n        mediaElement = this.createImageElement(transformedImageUrl, element);\n        break;\n    }\n\n    // Preserve classes and attributes from original element\n    this.transferAttributes(element, mediaElement);\n    \n    // Insert new media element\n    parent.appendChild(mediaElement);\n    \n    this.log(`Created ${mediaType} element for URL: ${url}`);\n  }\n\n  /**\n   * Detect media type from URL\n   */\n  private detectMediaType(url: string): 'image' | 'video' {\n    if (!url || typeof url !== 'string') {\n      this.log('Invalid URL provided to detectMediaType:', url);\n      return 'image';\n    }\n    \n    const urlLower = url.toLowerCase();\n    \n    // If optimizing GIFs as videos, treat them as such immediately.\n    if (this.config.optimizeGifsAsVideo && urlLower.endsWith('.gif')) {\n        return 'video';\n    }\n    \n    // Video formats - check for extensions and Cloudinary video path\n    const videoExtensions = ['.mp4', '.webm', '.mov', '.avi', '.mkv', '.ogg'];\n    const isVideoExtension = videoExtensions.some(ext => urlLower.endsWith(ext));\n    const isCloudinaryVideo = urlLower.includes('cloudinary.com/') && urlLower.includes('/video/');\n    \n    if (isVideoExtension || isCloudinaryVideo) {\n      return 'video';\n    }\n    \n    // Default to image\n    return 'image';\n  }\n\n  /**\n   * Create video element with fallback\n   */\n  private createVideoElement(url: string, originalElement: Element): HTMLVideoElement {\n    const video = document.createElement('video');\n    \n    // Video attributes\n    video.src = url;\n    video.loop = this.config.videoLoop;\n    video.playsInline = true; // Essential for inline playback on iOS\n    video.preload = 'metadata';\n    video.controls = this.config.videoControls;\n    \n    // Set a poster image proactively for better mobile compatibility and UX.\n    const posterUrl = this.extractVideoThumbnail(url);\n    if (posterUrl) {\n      video.poster = posterUrl;\n      this.log(`Set poster for video ${url}: ${posterUrl}`);\n    }\n\n    // Muted is critical for autoplay on mobile.\n    if (this.config.videoMuted) {\n        video.muted = true;\n        video.setAttribute('muted', ''); // Set attribute for maximum compatibility\n    }\n    \n    // Maintain aspect ratio and object-fit from original\n    video.style.width = '100%';\n    video.style.height = '100%';\n    video.style.objectFit = 'cover';\n    video.style.borderRadius = 'inherit';\n    \n    // Autoplay configuration\n    if (this.config.videoAutoplay) {\n      video.autoplay = true;\n      video.setAttribute('autoplay', '');\n      \n      // Programmatically play the video to support mobile autoplay, which often ignores the attribute alone.\n      // The promise is caught to handle cases where the browser blocks autoplay (e.g., Low Power Mode).\n      const playPromise = video.play();\n      if (playPromise !== undefined) {\n        playPromise.catch(error => {\n          this.log('Autoplay was prevented.', { error, videoUrl: url });\n        });\n      }\n    }\n    \n    // Error handling with fallback to poster or placeholder\n    video.onerror = () => {\n      this.log(`Video failed to load: ${url}`);\n      // Create a fallback image element\n      const fallbackImg = this.createImageElement(posterUrl || url, originalElement);\n      if (video.parentElement) {\n        video.parentElement.replaceChild(fallbackImg, video);\n      }\n    };\n\n    // Hover-to-play functionality (if enabled and not autoplay)\n    if (this.config.videoHoverPlay && !this.config.videoAutoplay) {\n      // --- Desktop hover events ---\n      video.addEventListener('mouseenter', () => {\n        video.currentTime = 0;\n        video.play().catch(() => { /* Ignore play errors */ });\n        });\n      video.addEventListener('mouseleave', () => {\n        video.pause();\n        video.currentTime = 0;\n      });\n      \n      // --- Mobile & Desktop click/tap events ---\n      video.addEventListener('click', (e) => {\n        e.preventDefault(); // Prevent navigation if video is in a link\n        if (video.paused) {\n          video.currentTime = 0;\n          video.play().catch((err) => this.log('Video play failed on click', err));\n        } else {\n          video.pause();\n        }\n      });\n    }\n\n    return video;\n  }\n\n  /**\n   * Create image element with error handling\n   */\n  private createImageElement(url: string, originalElement: Element): HTMLImageElement {\n    const img = document.createElement('img');\n    \n    img.src = url;\n    img.alt = originalElement.getAttribute('alt') || 'Media content';\n    img.loading = 'lazy';\n    \n    // Maintain styling\n    img.style.width = '100%';\n    img.style.height = '100%';\n    img.style.objectFit = 'cover';\n    img.style.borderRadius = 'inherit';\n    \n    // Error handling\n    img.onerror = () => {\n      this.log(`Image failed to load: ${url}`);\n      img.style.background = '#f3f4f6';\n      img.style.opacity = '0.5';\n      img.alt = 'Image unavailable';\n      \n      // Add broken image icon\n      img.style.position = 'relative';\n      const placeholder = document.createElement('div');\n      placeholder.style.cssText = `\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        color: #9ca3af;\n        font-size: 12px;\n        text-align: center;\n      `;\n      placeholder.textContent = 'ðŸ–¼ï¸ Image unavailable';\n      img.parentElement?.appendChild(placeholder);\n    };\n\n    return img;\n  }\n\n  /**\n   * Extract video thumbnail from Cloudinary URL\n   */\n  private extractVideoThumbnail(videoUrl: string): string | null {\n    // Loosened the check to work for any Cloudinary upload URL\n    if (!videoUrl.includes('/upload/')) {\n        this.log('URL does not appear to be a Cloudinary video, cannot generate poster.', videoUrl);\n    return null;\n    }\n\n    // Always change the file extension to .jpg for the poster\n    let posterUrl = videoUrl.replace(/\\.(mp4|webm|mov|avi|mkv|ogg|gif)$/i, '.jpg');\n\n    const uploadMarker = '/upload/';\n    const parts = posterUrl.split(uploadMarker);\n\n    if (parts.length !== 2) {\n        this.log(`Could not parse URL for thumbnail generation: ${videoUrl}`);\n        return posterUrl;\n    }\n\n    const [baseUrl, path] = parts;\n    let pathComponents = path.split('/');\n    \n    const firstPathComponent = pathComponents[0];\n    const hasTransformations = CLOUDINARY_TRANSFORM_PREFIXES.some(prefix => firstPathComponent.includes(prefix));\n\n    if (!hasTransformations) {\n        this.log(`No Cloudinary transformations found, returning basic .jpg poster URL for: ${videoUrl}`);\n        return posterUrl;\n    }\n\n    let transformations = pathComponents.shift() || '';\n    \n    // Remove params not ideal for a static poster (e.g., flags like fl_progressive)\n    const params = transformations.split(',');\n    const filteredParams = params.filter(param => \n        !param.startsWith('fl_') && \n        param !== 'f_auto'\n    );\n\n    const newTransformations = filteredParams.join(',');\n\n    if (newTransformations) {\n        pathComponents.unshift(newTransformations);\n    }\n\n    const newPath = pathComponents.join('/');\n    const finalUrl = `${baseUrl}${uploadMarker}${newPath}`;\n    \n    this.log(`Generated poster URL: ${finalUrl} from video URL: ${videoUrl}`);\n    return finalUrl;\n  }\n\n  /**\n   * Transfer attributes and classes from old element to new\n   */\n  private transferAttributes(from: Element, to: HTMLElement): void {\n    // Transfer classes\n    if (from.className) {\n      to.className = from.className;\n    }\n    \n    // Transfer data attributes (except contra-field)\n    Array.from(from.attributes).forEach(attr => {\n      if (attr.name.startsWith('data-') && attr.name !== `${ATTR_PREFIX}${ATTRS.field}`) {\n        to.setAttribute(attr.name, attr.value);\n      }\n    });\n    \n    // Transfer style\n    if (from.getAttribute('style')) {\n      const existingStyle = to.getAttribute('style') || '';\n      to.setAttribute('style', existingStyle + '; ' + from.getAttribute('style'));\n    }\n  }\n\n  /**\n   * Handle repeating elements (projects, social links)\n   */\n  private populateRepeatingElements(card: Element, expert: ExpertProfile, listId: string): void {\n    const repeatElements = this.querySelectorAll(card, `[${ATTR_PREFIX}${ATTRS.repeat}]`);\n    \n    repeatElements.forEach(container => {\n      const repeatType = this.getAttr(container, ATTRS.repeat);\n      const maxItems = parseInt(this.getAttr(container, ATTRS.max) || '10');\n      \n      if (repeatType === 'projects' && expert.projects) {\n        this.populateRepeatingContainer(container, expert.projects.slice(0, maxItems), listId);\n      } else if (repeatType === 'socialLinks' && expert.socialLinks) {\n        this.populateRepeatingContainer(container, expert.socialLinks.slice(0, maxItems), listId);\n      } else if (repeatType === 'skillTags' && expert.skillTags) {\n        this.populateRepeatingContainer(container, expert.skillTags.slice(0, maxItems).map((tag: string) => ({ name: tag })), listId);\n      }\n    });\n  }\n\n  /**\n   * Populate a repeating container with items\n   */\n  private populateRepeatingContainer(container: Element, items: any[], listId: string): void {\n    const template = container.firstElementChild;\n    if (!template) return;\n\n    // Clear existing items\n    container.innerHTML = '';\n    \n    // Create items from template\n    items.forEach(item => {\n      const itemElement = template.cloneNode(true) as Element;\n      // The template pollution is fixed, so we can reliably use populateFields for all item types.\n      this.populateFields(itemElement, item, listId);\n      container.appendChild(itemElement);\n    });\n    \n    // Hide container if no items\n    if (items.length === 0) {\n      (container as HTMLElement).style.display = 'none';\n    }\n  }\n\n  /**\n   * Handle conditional display based on data\n   */\n  private handleConditionalDisplay(card: Element, expert: ExpertProfile): void {\n    const conditionalElements = this.querySelectorAll(card, `[${ATTR_PREFIX}${ATTRS.showWhen}], [${ATTR_PREFIX}${ATTRS.hideWhen}]`);\n    \n    conditionalElements.forEach(element => {\n      const showWhen = this.getAttr(element, ATTRS.showWhen);\n      const hideWhen = this.getAttr(element, ATTRS.hideWhen);\n      \n      let shouldShow = true;\n      \n      if (showWhen) {\n        shouldShow = this.evaluateCondition(expert, showWhen);\n      }\n      \n      if (hideWhen) {\n        shouldShow = shouldShow && !this.evaluateCondition(expert, hideWhen);\n      }\n      \n      (element as HTMLElement).style.display = shouldShow ? '' : 'none';\n    });\n  }\n\n  /**\n   * Evaluate a condition against expert data\n   */\n  private evaluateCondition(expert: ExpertProfile, condition: string): boolean {\n    if (!condition || typeof condition !== 'string') {\n      this.log('Invalid condition provided:', condition);\n      return false;\n    }\n    \n    // Parse condition: \"field:value\" or \"field:>value\" etc.\n    const parts = condition.split(':');\n    if (parts.length < 2) {\n      this.log('Invalid condition format:', condition);\n      return false;\n    }\n    \n    const field = parts[0];\n    const restOfCondition = parts.slice(1).join(':'); // Handle colons in values\n    const expertValue = (expert as any)[field];\n    \n    this.log(`Evaluating condition: ${field} (${expertValue}, type: ${typeof expertValue}) against ${restOfCondition}`);\n    \n    if (expertValue == null) {\n      this.log(`Field '${field}' is null/undefined, condition fails`);\n      return false;\n    }\n    \n    // Check for comparison operators\n    if (restOfCondition.startsWith('>=')) {\n      const value = restOfCondition.substring(2);\n      const result = Number(expertValue) >= Number(value);\n      this.log(`Comparison: ${expertValue} >= ${value} = ${result}`);\n      return result;\n    } else if (restOfCondition.startsWith('<=')) {\n      const value = restOfCondition.substring(2);\n      const result = Number(expertValue) <= Number(value);\n      this.log(`Comparison: ${expertValue} <= ${value} = ${result}`);\n      return result;\n    } else if (restOfCondition.startsWith('>')) {\n      const value = restOfCondition.substring(1);\n      const result = Number(expertValue) > Number(value);\n      this.log(`Comparison: ${expertValue} > ${value} = ${result}`);\n      return result;\n    } else if (restOfCondition.startsWith('<')) {\n      const value = restOfCondition.substring(1);\n      const result = Number(expertValue) < Number(value);\n      this.log(`Comparison: ${expertValue} < ${value} = ${result}`);\n      return result;\n    } else {\n      // Direct value comparison with type-aware handling\n      let result = false;\n      \n      // Handle boolean fields specially\n      if (typeof expertValue === 'boolean') {\n        // Convert string condition to boolean for comparison\n        if (restOfCondition.toLowerCase() === 'true') {\n          result = expertValue === true;\n        } else if (restOfCondition.toLowerCase() === 'false') {\n          result = expertValue === false;\n        } else {\n          result = false;\n        }\n        this.log(`Boolean comparison: ${expertValue} === ${restOfCondition.toLowerCase() === 'true'} = ${result}`);\n      } else if (typeof expertValue === 'number') {\n        // Handle numeric comparisons\n        const numValue = Number(restOfCondition);\n        result = !isNaN(numValue) && expertValue === numValue;\n        this.log(`Number comparison: ${expertValue} === ${numValue} = ${result}`);\n      } else {\n        // String comparison (case-insensitive)\n        const expertStr = String(expertValue);\n        const valueStr = String(restOfCondition);\n        result = expertStr.toLowerCase() === valueStr.toLowerCase();\n        this.log(`String comparison: '${expertStr}' === '${valueStr}' = ${result}`);\n      }\n      \n      return result;\n    }\n  }\n\n  /**\n   * Update UI states based on current data for a specific list.\n   */\n  private updateUIStates(listElement: Element, listId: string): void {\n    const state = this.state.getState(listId);\n    \n    const emptyElement = this.querySelector(listElement, `[${ATTR_PREFIX}${ATTRS.empty}]`);\n    if (emptyElement) {\n        const showEmpty = !state.loading && state.experts.length === 0;\n        const display = showEmpty ? 'block' : 'none';\n        (emptyElement as HTMLElement).style.setProperty('display', display, 'important');\n        this.log(`List ${listId}: Empty state display set to '${display}'.`);\n    }\n    \n    const loadMoreButton = this.querySelector(document.body, `[${ATTR_PREFIX}${ATTRS.action}=\"load-more\"][${ATTR_PREFIX}${ATTRS.listTarget}=\"${listId}\"]`);\n    if (loadMoreButton) {\n      const btn = loadMoreButton as HTMLButtonElement;\n      const hasMore = !state.loading && state.hasNextPage;\n      const display = hasMore ? 'inline-block' : 'none';\n      (loadMoreButton as HTMLElement).style.setProperty('display', display, 'important');\n      btn.disabled = state.loading;\n      btn.textContent = state.loading ? 'Loading...' : 'Load More';\n    }\n  }\n\n  /**\n   * Handle action buttons (just load-more for now).\n   */\n  private handleAction(action: string, targetListId: string, button: Element): void {\n    if (action === 'load-more') {\n      const listElement = this.querySelector(document.body, `[${ATTR_PREFIX}${ATTRS.listId}=\"${targetListId}\"]`);\n      const programId = this.getAttr(listElement!, ATTRS.program);\n      if (listElement && programId) {\n        this.loadExperts(targetListId, programId, true); // `true` to append\n      } else {\n        this.log(`Could not find list or program for target: ${targetListId}`);\n      }\n    } else if (action === 'clear-filters') {\n      this.clearFilters(targetListId);\n    }\n  }\n\n  private clearFilters(targetListId: string): void {\n    const listElement = this.querySelector(document.body, `[${ATTR_PREFIX}${ATTRS.listId}=\"${targetListId}\"]`);\n    if (!listElement) {\n        this.log(`Cannot find list element with ID: ${targetListId} to clear filters.`);\n        return;\n    }\n    const programId = this.getAttr(listElement, ATTRS.program);\n    if (!programId) {\n        this.log(`Cannot find programId for list: ${targetListId}`);\n        return;\n    }\n\n    this.log(`Clearing filters for list: ${targetListId}`);\n\n    // 1. Reset state\n    this.state.updateState(targetListId, { filters: {}, offset: 0 });\n\n    // 2. Reset controls visually\n    const filterControls = this.querySelectorAll(document.body, `[data-contra-filter][data-contra-list-target=\"${targetListId}\"]`);\n    filterControls.forEach(control => {\n        this.resetControlValue(control as HTMLInputElement | HTMLSelectElement);\n    });\n\n    // 3. Reload data\n    this.loadExperts(targetListId, programId, false); // false to replace, not append\n  }\n\n  private resetControlValue(control: HTMLInputElement | HTMLSelectElement): void {\n    if (control instanceof HTMLInputElement) {\n        switch (control.type) {\n            case 'checkbox':\n            case 'radio':\n                control.checked = false;\n                break;\n            case 'number':\n            case 'range':\n                control.value = '';\n                break;\n            default: // text, search, etc.\n                control.value = '';\n                break;\n        }\n    } else if (control instanceof HTMLSelectElement) {\n        control.selectedIndex = 0; // Reset to the first option\n    }\n  }\n\n  private updateFilterAndReload(listId: string, programId: string, filterKey: string, value: any): void {\n    const state = this.state.getState(listId);\n    const newFilters = { ...state.filters };\n\n    // Process and set value\n    let processedValue = value;\n    if (filterKey === 'available') {\n      // If checkbox is checked, value is true. If unchecked, it's false.\n      // We only want to apply the filter when it's true.\n      processedValue = value ? true : undefined;\n    } else if (['minRate', 'maxRate'].includes(filterKey)) {\n      processedValue = (value === '' || value === null) ? undefined : Number(value);\n    } else if (filterKey === 'languages' && typeof value === 'string') {\n        processedValue = value.split(',').map(v => v.trim()).filter(v => v);\n        if (processedValue.length === 0) {\n            processedValue = undefined;\n        }\n    }\n\n    if (processedValue !== undefined && processedValue !== '') {\n        const apiKey = this.filterNameMap[filterKey] || filterKey;\n        (newFilters as any)[apiKey] = processedValue;\n    } else {\n        const apiKey = this.filterNameMap[filterKey] || filterKey;\n        delete (newFilters as any)[apiKey];\n    }\n    \n    // Reset offset and update state\n    this.state.updateState(listId, { filters: newFilters, offset: 0 });\n\n    this.log(`Filter updated for list ${listId}, reloading. New filters:`, newFilters);\n    \n    // Reload the list\n    this.loadExperts(listId, programId, false);\n  }\n\n  private wireFilterControls(): void {\n    const filterControls = this.querySelectorAll(document.body, `[data-contra-filter]`);\n    this.log(`Found ${filterControls.length} filter controls to wire.`);\n\n    filterControls.forEach(control => {\n        const filterKey = control.getAttribute('data-contra-filter');\n        const targetListId = control.getAttribute('data-contra-list-target');\n\n        if (!filterKey || !targetListId) {\n            this.log('Filter control missing required attributes: data-contra-filter or data-contra-list-target', control);\n            return;\n        }\n\n        const listElement = this.querySelector(document.body, `[${ATTR_PREFIX}list-id=\"${targetListId}\"]`);\n        if (!listElement) return;\n        const programId = this.getAttr(listElement, ATTRS.program);\n        if (!programId) return;\n\n        const debounceTime = (control instanceof HTMLInputElement && ['text', 'search'].includes(control.type)) ? 300 : 0;\n        \n        const handler = () => {\n            const value = this.getControlValue(control as HTMLInputElement | HTMLSelectElement);\n            this.updateFilterAndReload(targetListId, programId, filterKey, value);\n        };\n        \n        const debouncedHandler = this.debounce(handler, debounceTime);\n        \n        const eventType = (control instanceof HTMLInputElement && ['text', 'search'].includes(control.type)) ? 'input' : 'change';\n        control.addEventListener(eventType, debouncedHandler);\n    });\n  }\n\n  private debounce(func: (...args: any[]) => void, delay: number): (...args: any[]) => void {\n    let timeoutId: number;\n    return (...args: any[]) => {\n        clearTimeout(timeoutId);\n        if (delay > 0) {\n            timeoutId = window.setTimeout(() => func.apply(this, args), delay);\n        } else {\n            func.apply(this, args);\n        }\n    };\n  }\n\n  /**\n   * Utility Methods\n   */\n  private getAttr(element: Element, name: string): string | null {\n    return element.getAttribute(`${ATTR_PREFIX}${name}`);\n  }\n\n  private querySelector(element: Element, selector: string): Element | null {\n    return element.querySelector(selector);\n  }\n\n  private querySelectorAll(element: Element, selector: string): Element[] {\n    return Array.from(element.querySelectorAll(selector));\n  }\n\n  private parseFiltersFromElement(element: Element): ExpertFilters {\n    const filters: ExpertFilters = {};\n    \n    // Parse filter attributes\n    const filterMap = {\n      'available': 'available',\n      'languages': 'languages', \n      'location': 'location',\n      'min-rate': 'minRate',\n      'max-rate': 'maxRate',\n      'sort': 'sortBy',\n      'limit': 'limit',\n      'offset': 'offset'\n    };\n\n    Object.entries(filterMap).forEach(([attr, filterKey]) => {\n      const value = this.getAttr(element, attr);\n      if (value != null) {\n        if (filterKey === 'available') {\n          (filters as any)[filterKey] = value === 'true';\n        } else if (filterKey === 'languages') {\n          (filters as any)[filterKey] = value.split(',').map(v => v.trim());\n        } else if (['minRate', 'maxRate', 'limit', 'offset'].includes(filterKey)) {\n          (filters as any)[filterKey] = parseInt(value);\n        } else {\n          (filters as any)[filterKey] = value;\n        }\n      }\n    });\n\n    // Ensure offset defaults to 0 if not specified\n    if (filters.offset === undefined) {\n      filters.offset = 0;\n    }\n\n    return filters;\n  }\n\n  private getControlValue(control: HTMLInputElement | HTMLSelectElement): any {\n    if (control instanceof HTMLInputElement) {\n      switch (control.type) {\n        case 'checkbox':\n          return control.checked;\n        case 'number':\n        case 'range':\n          return control.valueAsNumber;\n        default:\n          return control.value;\n      }\n    } else if (control instanceof HTMLSelectElement) {\n      if (control.multiple) {\n        return Array.from(control.selectedOptions).map(option => option.value);\n      }\n      return control.value;\n    }\n    return null;\n  }\n\n  private showLoading(container: Element, show: boolean): void {\n    const loadingElement = this.querySelector(container, `[${ATTR_PREFIX}${ATTRS.loading}]`);\n    if (loadingElement) {\n      const display = show ? 'block' : 'none';\n      (loadingElement as HTMLElement).style.setProperty('display', display, 'important');\n    }\n  }\n\n  private showError(container: Element, error: Error): void {\n    const errorElement = this.querySelector(container, `[${ATTR_PREFIX}${ATTRS.error}]`);\n    if (errorElement) {\n      errorElement.textContent = error.message;\n      (errorElement as HTMLElement).style.setProperty('display', 'block', 'important');\n    }\n    (container as HTMLElement).classList.add(this.config.errorClass);\n    this.log('Error displayed', error);\n  }\n\n  private dispatchEvent(target: Element | Document, eventName: string, detail: any): void {\n    const event = new CustomEvent(`contra:${eventName}`, { detail });\n    target.dispatchEvent(event);\n  }\n\n  private log(message: string, ...args: any[]): void {\n    if (this.config.debug) {\n      console.log(`[ContraWebflow] ${message}`, ...args);\n    }\n  }\n\n  private async getAvailableFilters(programId: string): Promise<any[]> {\n    const url = `https://contra.com/public-api/programs/${programId}/filters`;\n    this.log(`Fetching available filters for program: ${programId}`);\n    try {\n        const response = await fetch(url, {\n            headers: {\n                'X-API-Key': this.config.apiKey,\n                'Accept': 'application/json'\n            }\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to fetch filters: ${response.statusText}`);\n        }\n        const data = await response.json();\n        this.log('Successfully fetched filters', data.data);\n        return data.data || [];\n    } catch (error) {\n        this.log('Error fetching available filters', error);\n        return [];\n    }\n  }\n  \n  private getFilterOptionLabel(filterKey: string, value: string): string {\n    const labels = this.filterOptionLabels[filterKey];\n    if (labels && labels[value]) {\n      return labels[value];\n    }\n    // Capitalize the first letter and lowercase the rest as a fallback\n    return value.charAt(0).toUpperCase() + value.slice(1).toLowerCase();\n  }\n\n  private populateAllFilterControls(programFilters: Map<string, any[]>): void {\n    this.log('Populating all filter controls on the page...');\n    const allControls = this.querySelectorAll(document.body, `[data-contra-filter]`);\n\n    allControls.forEach(control => {\n      const targetListId = control.getAttribute('data-contra-list-target');\n      if (!targetListId) return;\n\n      const targetList = this.querySelector(document.body, `[data-contra-list-id=\"${targetListId}\"]`);\n      if (!targetList) return;\n\n      const programId = this.getAttr(targetList, ATTRS.program);\n      if (!programId) return;\n\n      const filters = programFilters.get(programId);\n      if (!filters) return;\n\n      const filterKey = control.getAttribute('data-contra-filter');\n      const filterDef = filters.find(f => f.name === filterKey);\n\n      if (!filterDef) return;\n\n      // Handle number input ranges\n      if (filterDef.type === 'number' && control instanceof HTMLInputElement) {\n        if (filterDef.minimum !== undefined) control.min = String(filterDef.minimum);\n        if (filterDef.maximum !== undefined) control.max = String(filterDef.maximum);\n      }\n      \n      // Handle populating controls with options (select, datalist)\n      if (filterDef.options) {\n          if (control instanceof HTMLSelectElement) {\n              this.populateSelectControl(control, filterKey!, filterDef.options);\n          } else if (control instanceof HTMLInputElement && control.getAttribute('list')) {\n              this.populateDatalistControl(control, filterKey!, filterDef.options);\n          }\n      }\n    });\n  }\n\n  private populateSelectControl(control: HTMLSelectElement, filterKey: string, options: any[]): void {\n    this.log(`Populating options for filter '${filterKey}' on control`, control);\n    \n    const placeholder = control.firstElementChild?.cloneNode(true) as Element | null;\n    control.innerHTML = '';\n    if (placeholder && placeholder.getAttribute('value') === '') {\n      control.appendChild(placeholder);\n    }\n\n    options.forEach((option: any) => {\n      const optionElement = document.createElement('option');\n      const value = typeof option === 'object' && option.value !== undefined ? option.value : String(option);\n      \n      optionElement.value = value;\n\n      let label: string;\n      if (filterKey === 'locations') {\n        const labelMatch = value.match(/^(.*?)\\s*\\(/);\n        label = labelMatch ? labelMatch[1].trim() : value;\n      } else {\n        label = this.getFilterOptionLabel(filterKey!, value);\n      }\n      optionElement.textContent = label;\n      \n      if (filterKey === 'sortBy' && value === 'relevance') {\n        optionElement.selected = true;\n      }\n      control.appendChild(optionElement);\n    });\n  }\n\n  private populateDatalistControl(control: HTMLInputElement, filterKey: string, options: any[]): void {\n      const datalistId = control.getAttribute('list');\n      if (!datalistId) return;\n\n      const datalist = document.getElementById(datalistId);\n      if (!datalist) {\n          this.log(`Datalist with id '${datalistId}' not found for input control.`, control);\n          return;\n      }\n\n      this.log(`Populating datalist '#${datalistId}' for filter '${filterKey}'`);\n      datalist.innerHTML = ''; // Clear existing options\n\n      options.forEach((option: any) => {\n          const optionElement = document.createElement('option');\n          const value = typeof option === 'object' && option.value !== undefined ? option.value : String(option);\n          \n          let displayValue = value;\n          // For locations, we want a cleaner value for the user to select.\n          if (filterKey === 'locations') {\n              const labelMatch = value.match(/^(.*?)\\s*\\(/);\n              displayValue = labelMatch ? labelMatch[1].trim() : value;\n          }\n\n          optionElement.value = displayValue;\n          datalist.appendChild(optionElement);\n      });\n  }\n\n  private transformMediaUrl(url: string, mediaType: 'image' | 'video'): string {\n    if (!url || (!url.includes('cloudinary.com/') && !url.includes('media.contra.com/'))) {\n        return url;\n    }\n\n    const transformations = mediaType === 'image' \n        ? this.config.imageTransformations \n        : this.config.videoTransformations;\n\n    if (!transformations) {\n        return url;\n    }\n\n    let processedUrl = url;\n    if (mediaType === 'video' && url.toLowerCase().endsWith('.gif')) {\n        processedUrl = url.replace(/\\.gif$/i, '.mp4');\n        this.log(`Converting GIF to MP4: ${processedUrl}`);\n    }\n\n    const uploadMarker = '/upload/';\n    const parts = processedUrl.split(uploadMarker);\n\n    if (parts.length !== 2) {\n        this.log(`Could not apply transformations, URL format unexpected: ${processedUrl}`);\n        return processedUrl;\n    }\n    \n    const [baseUrl, path] = parts;\n    let pathComponents = path.split('/');\n    \n    const firstPathComponent = pathComponents[0];\n    const hasExistingTransformations = CLOUDINARY_TRANSFORM_PREFIXES.some(prefix => firstPathComponent.includes(prefix));\n\n    if (hasExistingTransformations) {\n        this.log(`Removing existing transformations from URL: ${processedUrl}`);\n        pathComponents.shift();\n    }\n\n    const cleanPath = pathComponents.join('/');\n    const finalUrl = `${baseUrl}${uploadMarker}${transformations}/${cleanPath}`;\n    \n    this.log(`Transformed ${mediaType} URL from \"${url}\" to \"${finalUrl}\"`);\n    return finalUrl;\n  }\n\n  private _stringifyFilters(filters: ExpertFilters): string {\n    return Object.entries(filters)\n      .filter(([, value]) => {\n        if (value === null || value === undefined) return false;\n        if (Array.isArray(value) && value.length === 0) return false; // Exclude empty arrays\n        if (typeof value === 'string' && value.trim() === '') return false; // Exclude empty strings\n        // Keep numbers (like 0) and booleans\n        return true;\n      })\n      .map(([key, value]) => {\n        const stringValue = Array.isArray(value) ? value.join(',') : String(value);\n        return `${key}:${stringValue}`;\n      })\n      .join('|');\n  }\n\n  private _appendContraAnalytics(url: string, listId: string): string {\n    if (!this.config.contraAnalytics || !url) {\n      return url;\n    }\n\n    try {\n      // Find the list element in the main document to ensure it's the rendered one\n      const listElement = document.querySelector(`[${ATTR_PREFIX}${ATTRS.listId}=\"${listId}\"]`);\n      if (!listElement) return url;\n\n      const programId = this.getAttr(listElement, ATTRS.program);\n      const state = this.state.getState(listId);\n      \n      // We want the *current* filters from the state, which is correct\n      const filters = state.filters;\n\n      const params = new URLSearchParams();\n      params.set('contra_source', 'webflow_sdk');\n      if (programId) params.set('contra_program_id', programId);\n      if (listId) params.set('contra_list_id', listId);\n      \n      const filterString = this._stringifyFilters(filters);\n      if (filterString) {\n        params.set('contra_filters', filterString);\n      }\n\n      // Check if the URL is valid before creating a URL object\n      if (!url.startsWith('http')) {\n        this.log('Cannot append analytics to a relative or invalid URL', { url });\n        return url;\n      }\n\n      const urlObject = new URL(url);\n      \n      params.forEach((value, key) => {\n        // Use set instead of append to avoid duplicate params if logic is ever re-run\n        urlObject.searchParams.set(key, value);\n      });\n\n      return urlObject.toString();\n\n    } catch (error) {\n      this.log('Failed to append Contra analytics to URL.', { url, error });\n      return url; // Return original URL on error\n    }\n  }\n}\n\n/**\n * Auto-initialize runtime when DOM is ready\n */\nfunction autoInit(): void {\n  const configElement = document.getElementById('contra-config');\n  if (!configElement) {\n    console.warn('[ContraWebflow] No config element found. Runtime not initialized.');\n    return;\n  }\n\n  try {\n    const config = JSON.parse(configElement.textContent || '{}');\n    \n    // Validate required config\n    if (!config.apiKey) {\n      console.error('[ContraWebflow] API key is required in config.');\n      return;\n    }\n    \n    const initializeRuntime = () => {\n    const runtime = new ContraWebflowRuntime(config);\n    \n    // Expose runtime globally for debugging\n    (window as any).contraRuntime = runtime;\n    \n    runtime.init().catch(error => {\n      console.error('[ContraWebflow] Runtime initialization failed:', error);\n    });\n    };\n    \n    // Use setTimeout to ensure DOM is fully ready\n    setTimeout(initializeRuntime, 100);\n    \n  } catch (error) {\n    console.error('[ContraWebflow] Failed to parse config:', error);\n  }\n}\n\n// Auto-initialize when DOM is ready with multiple fallbacks\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', autoInit);\n} else if (document.readyState === 'interactive') {\n  // DOM is ready but resources might still be loading\n  setTimeout(autoInit, 50);\n} else {\n  // DOM and resources are ready\n  autoInit();\n}\n\n// Export runtime class for manual initialization\nexport { ContraWebflowRuntime as default }; ","import type {\n  ClientConfig,\n  ExpertProfile,\n  ExpertFilters,\n  ProgramSummary,\n  ListResponse,\n  ApiResponse,\n  ErrorResponse,\n  Filter,\n  FilterListResponse\n} from '@contra/types';\n\n/**\n * Professional Contra API Client\n * Features: Caching, retry logic, error handling, request deduplication\n */\nexport class ContraClient {\n  private config: Required<ClientConfig>;\n  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();\n  private pendingRequests = new Map<string, Promise<any>>();\n  \n  // Cache TTL settings (in milliseconds)\n  private static readonly CACHE_TTL = {\n    experts: 5 * 60 * 1000,      // 5 minutes for expert lists\n    expert: 10 * 60 * 1000,     // 10 minutes for individual experts\n    program: 30 * 60 * 1000,    // 30 minutes for program info\n    filters: 60 * 60 * 1000,    // 1 hour for available filters\n  };\n\n  constructor(config: ClientConfig) {\n    this.config = {\n      baseUrl: 'https://contra.com',\n      timeout: 10000,\n      debug: false,\n      ...config,\n    };\n\n    if (this.config.debug) {\n      console.log('[ContraClient] Initialized with config:', this.config);\n    }\n  }\n\n  /**\n   * Core fetch method with retry logic and error handling\n   */\n  private async fetch<T>(\n    endpoint: string,\n    options: RequestInit = {},\n    retries = 3\n  ): Promise<T> {\n    const url = `${this.config.baseUrl}${endpoint}`;\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);\n\n    const requestOptions: RequestInit = {\n      ...options,\n      signal: controller.signal,\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json',\n        'Authorization': this.config.apiKey,\n        'X-API-Key': this.config.apiKey,\n        ...options.headers,\n      },\n    };\n\n    try {\n      if (this.config.debug) {\n        console.log(`[ContraClient] Fetching: ${url}`, requestOptions);\n      }\n\n      const response = await fetch(url, requestOptions);\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        // Try to parse error response\n        let errorData: ErrorResponse;\n        try {\n          errorData = await response.json();\n        } catch {\n          errorData = {\n            code: `HTTP_${response.status}`,\n            message: response.statusText || 'Unknown error'\n          };\n        }\n\n        // Retry on 5xx errors or rate limits\n        if ((response.status >= 500 || response.status === 429) && retries > 0) {\n          const delay = Math.pow(2, 3 - retries) * 1000; // Exponential backoff\n          await new Promise(resolve => setTimeout(resolve, delay));\n          return this.fetch<T>(endpoint, options, retries - 1);\n        }\n\n        throw new ContraAPIError(errorData.message, errorData.code, response.status);\n      }\n\n      const data = await response.json();\n      \n      if (this.config.debug) {\n        console.log(`[ContraClient] Response:`, data);\n      }\n\n      return data;\n\n    } catch (error) {\n      clearTimeout(timeoutId);\n      \n      if (error instanceof ContraAPIError) {\n        throw error;\n      }\n\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw new ContraAPIError(`Request timeout after ${this.config.timeout}ms`, 'TIMEOUT');\n      }\n\n      // Network or other errors - retry if we have retries left\n      if (retries > 0) {\n        const delay = Math.pow(2, 3 - retries) * 1000;\n        await new Promise(resolve => setTimeout(resolve, delay));\n        return this.fetch<T>(endpoint, options, retries - 1);\n      }\n\n      throw new ContraAPIError(\n        error instanceof Error ? error.message : 'Unknown error',\n        'NETWORK_ERROR'\n      );\n    }\n  }\n\n  /**\n   * Get from cache or fetch with request deduplication\n   */\n  private async fetchWithCache<T>(\n    cacheKey: string,\n    endpoint: string,\n    ttl: number,\n    options?: RequestInit\n  ): Promise<T> {\n    // Check cache first\n    const cached = this.cache.get(cacheKey);\n    if (cached && Date.now() - cached.timestamp < cached.ttl) {\n      if (this.config.debug) {\n        console.log(`[ContraClient] Cache hit: ${cacheKey}`);\n      }\n      return cached.data;\n    }\n\n    // Check for pending request (deduplication)\n    const pendingKey = `${endpoint}${JSON.stringify(options)}`;\n    if (this.pendingRequests.has(pendingKey)) {\n      if (this.config.debug) {\n        console.log(`[ContraClient] Request deduplication: ${pendingKey}`);\n      }\n      return this.pendingRequests.get(pendingKey)!;\n    }\n\n    // Make the request\n    const requestPromise = this.fetch<T>(endpoint, options);\n    this.pendingRequests.set(pendingKey, requestPromise);\n\n    try {\n      const data = await requestPromise;\n      \n      // Cache the result\n      this.cache.set(cacheKey, {\n        data,\n        timestamp: Date.now(),\n        ttl\n      });\n\n      return data;\n    } finally {\n      this.pendingRequests.delete(pendingKey);\n    }\n  }\n\n  /**\n   * Build query string from filters\n   */\n  private buildQueryString(filters: ExpertFilters): string {\n    const params = new URLSearchParams();\n    \n    Object.entries(filters).forEach(([key, value]) => {\n      if (value != null && value !== '') {\n        if (Array.isArray(value)) {\n          params.set(key, value.join(','));\n        } else {\n          params.set(key, String(value));\n        }\n      }\n    });\n\n    const queryString = params.toString();\n    return queryString ? `?${queryString}` : '';\n  }\n\n  /**\n   * Get program information\n   */\n  async getProgram(programNid: string): Promise<ProgramSummary> {\n    const cacheKey = `program:${programNid}`;\n    const endpoint = `/public-api/programs/${programNid}`;\n    \n    const response = await this.fetchWithCache<ApiResponse<ProgramSummary>>(\n      cacheKey,\n      endpoint,\n      ContraClient.CACHE_TTL.program\n    );\n    \n    return response.data;\n  }\n\n  /**\n   * List experts with advanced filtering and caching\n   */\n  async listExperts(\n    programNid: string,\n    filters: ExpertFilters = {}\n  ): Promise<ListResponse<ExpertProfile>> {\n    const queryString = this.buildQueryString(filters);\n    const cacheKey = `experts:${programNid}:${JSON.stringify(filters)}`;\n    const endpoint = `/public-api/programs/${programNid}/experts${queryString}`;\n    \n    return this.fetchWithCache<ListResponse<ExpertProfile>>(\n      cacheKey,\n      endpoint,\n      ContraClient.CACHE_TTL.experts\n    );\n  }\n\n  /**\n   * Search experts (using the main experts endpoint with filters)\n   */\n  async searchExperts(\n    programNid: string,\n    query: string,\n    filters: ExpertFilters = {}\n  ): Promise<ListResponse<ExpertProfile>> {\n    // Search is handled by client-side filtering since API doesn't support text search\n    const experts = await this.listExperts(programNid, filters);\n    \n    // Client-side filtering for search (since API doesn't support text search)\n    if (query.trim()) {\n      const searchTerm = query.toLowerCase();\n      experts.data = experts.data.filter(expert => \n        (expert.name && expert.name.toLowerCase().includes(searchTerm)) ||\n        (expert.oneLiner && expert.oneLiner.toLowerCase().includes(searchTerm)) ||\n        (expert.skillTags && expert.skillTags.some(tag => tag && tag.toLowerCase().includes(searchTerm)))\n      );\n    }\n    \n    return experts;\n  }\n\n  /**\n   * Get available filter options for a program\n   */\n  async getFilterOptions(programNid: string): Promise<FilterListResponse> {\n    const cacheKey = `filters:${programNid}`;\n    const endpoint = `/public-api/programs/${programNid}/filters`;\n    \n    return this.fetchWithCache<FilterListResponse>(\n      cacheKey,\n      endpoint,\n      ContraClient.CACHE_TTL.filters\n    );\n  }\n\n  /**\n   * Clear cache (useful for forced refreshes)\n   */\n  clearCache(pattern?: string): void {\n    if (pattern) {\n      // Clear specific cache entries\n      for (const key of this.cache.keys()) {\n        if (key.includes(pattern)) {\n          this.cache.delete(key);\n        }\n      }\n    } else {\n      // Clear all cache\n      this.cache.clear();\n    }\n\n    if (this.config.debug) {\n      console.log(`[ContraClient] Cache cleared${pattern ? ` (pattern: ${pattern})` : ''}`);\n    }\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats(): {\n    size: number;\n    entries: Array<{ key: string; age: number; ttl: number }>;\n  } {\n    const now = Date.now();\n    const entries = Array.from(this.cache.entries()).map(([key, value]) => ({\n      key,\n      age: now - value.timestamp,\n      ttl: value.ttl\n    }));\n\n    return {\n      size: this.cache.size,\n      entries\n    };\n  }\n}\n\n/**\n * Custom error class for API errors\n */\nexport class ContraAPIError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public status?: number\n  ) {\n    super(message);\n    this.name = 'ContraAPIError';\n  }\n}\n\n/**\n * Utility functions\n */\nexport const utils = {\n  /**\n   * Format hourly rate with proper handling of null values\n   */\n  formatRate(rate: number | null): string {\n    return rate ? `$${rate}/hr` : 'Rate on request';\n  },\n\n  /**\n   * Generate star rating HTML\n   */\n  renderStars(rating: number): string {\n    const fullStars = Math.floor(rating);\n    const hasHalfStar = (rating % 1) >= 0.5;\n    const emptyStars = 5 - fullStars - (hasHalfStar ? 1 : 0);\n    \n    let html = '';\n    \n    // Full stars\n    for (let i = 0; i < fullStars; i++) {\n      html += `<svg class=\"star star-full\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"#FFD700\">\n        <path d=\"M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z\"/>\n      </svg>`;\n    }\n    \n    // Half star\n    if (hasHalfStar) {\n      html += `<svg class=\"star star-half\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\n        <defs>\n          <linearGradient id=\"half-${rating}\">\n            <stop offset=\"50%\" stop-color=\"#FFD700\"/>\n            <stop offset=\"50%\" stop-color=\"#E5E5E5\"/>\n          </linearGradient>\n        </defs>\n        <path fill=\"url(#half-${rating})\" d=\"M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z\"/>\n      </svg>`;\n    }\n    \n    // Empty stars\n    for (let i = 0; i < emptyStars; i++) {\n      html += `<svg class=\"star star-empty\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"#E5E5E5\">\n        <path d=\"M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z\"/>\n      </svg>`;\n    }\n    \n    return html;\n  },\n\n  /**\n   * Debounce function for search inputs\n   */\n  debounce<T extends (...args: any[]) => any>(\n    func: T,\n    wait: number\n  ): (...args: Parameters<T>) => void {\n    let timeout: NodeJS.Timeout;\n    return (...args: Parameters<T>) => {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => func(...args), wait);\n    };\n  },\n\n  /**\n   * Throttle function for scroll events\n   */\n  throttle<T extends (...args: any[]) => any>(\n    func: T,\n    limit: number\n  ): (...args: Parameters<T>) => void {\n    let inThrottle: boolean;\n    return (...args: Parameters<T>) => {\n      if (!inThrottle) {\n        func(...args);\n        inThrottle = true;\n        setTimeout(() => inThrottle = false, limit);\n      }\n    };\n  }\n}; "],"mappings":"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","names":["runtime_exports","__export","ContraWebflowRuntime","_ContraClient","config","endpoint","options","retries","url","controller","timeoutId","requestOptions","response","errorData","delay","resolve","ContraAPIError","data","error","cacheKey","ttl","cached","pendingKey","requestPromise","filters","params","key","value","queryString","programNid","query","experts","searchTerm","expert","tag","pattern","now","entries","ContraClient","message","code","status","utils","rate","rating","fullStars","hasHalfStar","emptyStars","html","i","func","wait","timeout","args","limit","inThrottle","CLOUDINARY_TRANSFORM_PREFIXES","ATTR_PREFIX","ATTRS","RuntimeState","listId","updates","state","ContraWebflowRuntime","config","f","listElements","programFilters","listElement","programId","error","limit","template","i","placeholder","loadingEl","emptyEl","initialFilters","response","newExperts","allExperts","button","action","targetListId","e","append","emptyElement","filters","experts","placeholders","expert","card","fragment","expertCard","repeatContainers","detachedTemplates","container","element","fieldName","format","value","href","mediaType","transformedUrl","displayValue","d","rating","fullStars","hasHalfStar","emptyStars","starsHtml","textElement","url","parent","mediaElement","transformedVideoUrl","transformedImageUrl","urlLower","isVideoExtension","ext","isCloudinaryVideo","originalElement","video","posterUrl","playPromise","fallbackImg","err","img","videoUrl","uploadMarker","parts","baseUrl","path","pathComponents","firstPathComponent","prefix","newTransformations","param","newPath","finalUrl","from","to","attr","existingStyle","repeatType","maxItems","tag","items","item","itemElement","showWhen","hideWhen","shouldShow","condition","field","restOfCondition","expertValue","result","numValue","expertStr","valueStr","display","loadMoreButton","btn","control","filterKey","newFilters","processedValue","v","apiKey","filterControls","debounceTime","handler","debouncedHandler","eventType","func","delay","timeoutId","args","name","selector","option","show","loadingElement","errorElement","target","eventName","detail","event","message","data","labels","targetList","filterDef","options","optionElement","label","labelMatch","datalistId","datalist","transformations","processedUrl","cleanPath","key","stringValue","params","filterString","urlObject","autoInit","configElement","runtime"]}